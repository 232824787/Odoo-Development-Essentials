#Chapter 3 Inheritance – Extending Existing Applications
*******************
One of Odoo's most powerful features is the ability to add features without directly modifying the underlying objects.  
Odoo最强大的一个特性便是能够不用直接修改底层对象就可以添加功能。  

This is achieved through inheritance mechanisms, functioning as modification layers on top of existing objects. These modifications can happen at all levels: models, views, and business logic. Instead of directly modifying an existing module, we create a new module to add the intended modifications.  

使用继承机制，在已存在对象的上层运行修改，就可以实现这个目的。这些修改在所有级别都都会发生：模型，视图，以及业务逻辑。与直接修改已存在模块相反，我们应该创建一个新的模块，以便添加所期望的修改。  

Here, you will learn how to write your own extension modules, empowering you to leverage existing core or community applications. As a relevant example, you will learn how to add Odoo's social and messaging features to your own modules.  

这里，你可以学到如何编写自己的扩展模块，使你能够改变已经存在的内核或者社区应用。举个例子来说，你可以学会如何将Odoo的社交和消息功能添加到自己的模块。  

## Adding sharing capability to the To-Do app 对To-Do添加共享
Our To-Do application now allows users to privately manage their own to-do
tasks. Won't it be great to take the app to another level by adding collaboration and social networking features to it? We will be able to share tasks and discuss them with other people.  

我们的To－Do应用现状可以让用户独立地管理自己的to－do任务。通过添加协作和社交网络功能就可以将应用提升到另外一个层次岂不是更好？这样，我们能够和其它人分享和讨论任务。  

We will do this with a new module to extend the previously created To-Do app to add these new features. Here is what we expect to achieve by the end of this chapter:  

我们将通过创建一个新的模块来扩张值钱创建的To-Do应用已添加这些新功能。下图是我们希望在本章结束时可以实现的目标：  

img:omit  

### Road map for the user sharing features 用户分享的路线图
Here is our work plan for the feature extensions to be implemented:   

这里是我们将要实现的功能扩展的工作计划：  

- Add fields to the Task model, such as the user who owns the task
- Modify the business logic to operate only on the current user's tasks, instead of all tasks the user is able to see
- Add the necessary fields to the views
- Add social networking features: the message wall and the followers

- 添加字段到Task模型，比如任务的创建人。  
- 仅对当前用户修改业务逻辑已操作，而不是修改用户可以看到的所有用户。  
- 对视图添加必须要的视图。  
- 添加社交网络功能：消息墙和粉丝。  

We will start creating the basic skeleton for the module alongside the todo_app module. Following the installation example in Chapter 1, Getting Started with Odoo Development we are hosting our modules at `~/odoo-dev/custom-addons/`:  

我们从在todo_app模块旁边为模块创建基本的框架开始。下面是一个第一章——Odoo开发入门钟的的安装示例，我们将这个模块放到`~/odoo-dev/custom-addons/`：  

```shell
$ mkdir ~/odoo-dev/custom-addons/todo_user
$ touch ~/odoo-dev/custom-addons/todo_user/__init__.py
```

Now create the `__openerp__.py`, containing this code:  

现在，创建一个包含以下代码的文件`__openerp__.py`：  

```json
   {  'name': 'Multiuser To-Do',
      'description': 'Extend the To-Do app to multiuser.',
      'author': 'Daniel Reis',
      'depends': ['todo_app'], }
```

We haven't done that, but including the summary and category keys can be important when publishing modules to the Odoo online app store.  

我们的工作还没有完成，而且对summary和category键的包括在发布模块到Odoo在线应用商店时特别重要。  

Next, we can install it. It should be enough to update the Modules List from the Settings menu, find the new module in the Local Modules list and click on its Install button. For more detailed instructions on discovering and installing a module you can refer back to Chapter 1, Getting Started with Odoo Development.  

接下来，我们可以安装这个模块。现在是时候从设置菜单更新模块列表了，找到本地模块中的新模块，然后点击它的安装按钮。关于发现和安装一个模块更多详细说明你可以回溯到第一章，Odoo开发入门。  

Now, let's start adding the new features to it.  

现在，我们开始对它添加新的功能。  

## Extending the to-do task model 扩展to-do的task模型
New models are defined through Python classes. Extending them is also done through Python classes, but using an Odoo specific mechanism.  

新模块是通过Python类来定义的。所以扩展模块也可以通过编写Python类来实现，而不是只使用Odoo的专用机制。  

To extend an existing model we use a Python class with a _inherit attribute. This identifies the model to be extended. The new class inherits all the features of the parent Odoo model, and we only need to declare the modifications that we wish to introduce.  

我们使用一个拥有_inherit属性的Python类来扩展已存在的模型。这个属性表明模型可以被扩展。新类继承了父级Odoo模型全部的特性，我们只需要声明希望应用的修改。  

In fact, Odoo models exist outside our particular module, in a central registry. This registry can also be referred to as the pool, and can be accessed from model methods using `self.env[<model name>]`. For example, to reference the `res.partner` model we would write `self.env['res.partner']`.  

实际上，Odoo模块存在我们特殊模块之外，在一个注册中心里面。这个注册中心可以被引用为pool，也可以使用`self.env[<model name>]`从模块的方法来访问。例如，要引用`res.partner`模型，我们可以这样写`self.env['res.partner']`。  

To modify an Odoo model we get a reference to its registry class and then perform in place changes on it. This means that these modifications will also be available everywhere else where the model is used.  

如果修改一个引用自模型注册中心的Odoo模型，那么可以模型执行原地修改。这就意味着，这些修改也可以运用在其它的使用到模型的地方。  

In the module loading sequence, during a server start, modifiations will only be visible to the modules loaded afterward. So, the loading sequence is important and we should make sure that the module dependencies are correctly set.  

按照模块的载入顺序，当服务器启动时，修改仅在模块被载入后可以看到。所以，载入顺序很很重要，我们应该保证模块依赖被正确地设置。  

### Adding fields to a model 对模型添加字段
We will extend the todo.task model to add a couple of fields to it: the user responsible for the task, and a deadline date.  

我们扩展todo.task模型以添加几个字段：用户负责的task以及截止日期。  

Create a new `todo_task.py` file declaring a class extending the original model:  

创建一个新的`todo_task.py` 文件以声明扩展原始模型的类：  

```python
# -*- coding: utf-8 -*-
from openerp import models, fields, api


class TodoTask(models.Model):
    _inherit = 'todo.task'
    user_id = fields.Many2one('res.users', 'Responsible')
    date_deadline = fields.Date('Deadline')
```

The class name is local to this Python file, and in general is irrelevant for other modules. The `_inherit` class attribute is the key here: it tells Odoo that this class is inheriting from the todo.task model. Notice the `_name` attribute absent. It is not needed because it is already inherited from the parent model.  

类名称在这个Python文件是个本地变量，通常与其它模块没有关联。类属性`_inherit`的重点是：它告诉Odoo这个类是从todo.task模型继承而来的。注意`_name`属性是不存在的。我们并不需要`_name`属性，因为这个属性已经从父模型继承了。  

The next two lines are regular field declarations. The `user_id` represents a user from the Users model, `res.users`. It's a Many2one field, the equivalent to a foreign key in database jargon. The date_deadline is a simple date field. In **Chapter 5, Models Structuring the Application Data** we will be explaining in more detail the types of fields available in Odoo.  

接下来的两行识常规字段的声明。`user_id`表示用户来自用户模型`res.users`。`res.users`是一个多对一字段，在数据库术语中它等同于外键。date_deadline 是一个简单的日期字段。在第五章——模型——结构化应用数据，我们会向详细解释Odoo中可用的字段类型。  

We still need to add to the `__init__.py` file the import statement to include it in the module:  

我们需要在模块中对`__init__.py`文件添加import语句以导入模块。  

```python
from . import todo_task
```

To have the new fields added to the model's supporting database table we need to perform a module upgrade. If everything goes as expected, you should see the new fields when inspecting the `todo.task` model, in the **Technical** menu, **Database Structure** | **Models** option.  

为了将新字段添加到模型支持的数据库表中，我们需要执行模块升级。如果没有问题话，你可以在检查Technical菜单的Database Structure| Models选项的`todo.task`模型时看到新字段。  

### Modifying existing fields 修改已存在的字段
As you can see, adding new fields to an existing model is quite straightforward. Since Odoo 8, modifying attributes on already existing fields is also possible. It's done by adding a field with the same name, and setting values only for the attributes to be changed.  

如你所见，对已存在的模型添加新字段相当简单直接。从Odoo 8开始，修改已存在的字段的属性也是可行的。通过添加一个同名字段

For example, to add a help tooltip to the name field, we could add this line to the `todo_task.py` described above:  

例如，对name字段添加一个工具提示，我们对上面提到的`todo_task.py`添加下面这一行内容：  

```python
name = fields.Char(help="What needs to be done?")
```

If we upgrade the module, go to a to-do task form, and pause the mouse pointer over the **Description** field, the above tooltip text will be displayed.  

如果需要我们升级模块，那么可以找到to-do task表单，然后把鼠标指针悬停在Description字段，上面的工具提示内容就回显示出来。  

### Modifying model's methods 修改模型的方法
Inheritance also works at the business logic level. Adding new methods is simple: just declare their functions inside the inheriting class.  

继承也可以运用在业务逻辑层面。添加新模块很简单：在继承类的内部声明类的函数就好了。  

To extend existing logic, the corresponding method can be overridden by declaring a method with the exact same name, and the new method will replace the previous one. But it can extend the code of the inherited class, by using Python's `super()` keyword to call the parent method.  

要扩展已存在的逻辑，你可以通过声明一个完全相同的名字来重写对应的方法，这样新方法就会替换之前的那个方法。不过，使用Python的`super()`关键字去调用父级方法就可以扩展类的代码。  

It's best to avoid changing the method's function signature (that is, keep the same arguments) to be sure that the existing calls on it will keep working properly. In case you need to add additional parameters, make them optional (with a default value) keyword arguments.  

最好避免改变方法函数的签名（也就是，使用相同的参数）以保证已经调用这个函数能够正常使用。这种情况，你需要添加额外的参数，对函数应用可选的（携带默认值）关键字参数。  

The original `Clear All Done` action is not appropriate for our task-sharing module anymore, since it clears all tasks regardless of their user. We need to modify it so that it clears only the current user tasks.  

原始的`Clear All Done`动作对于task-sharing模块来说已经不在适用，因为这个动作无视模块的用户就去清除所有的任务。我们需要修改它，让它只能够修改当前用户的任务。  

For this, we will override the original method with a new version that first finds the list of completed tasks for the current user, and then inactivates them:  

为此，我们用一个新方法来重写原始的方法，该新方法首先找到当前用户的已完成任务列表，然后激活这些列表：  

```python
    @api.multi
    def do_clear_done(self):
        domain = [('is_done', '=', True),  '|', ('user_id', '=', self.env.uid), ('user_id', '=', False)]
        done_recs = self.search(domain)
        done_recs.write({'active': False})
        return True
```

We first list the `done` records to act upon using the search method with a filter expression. The  lter expression follows an Odoo speci c syntax referred to as a domain.  

我们首先

The filter domain used is de ned the  rst instruction: it is a list of conditions, where each condition is a tuple.
These conditions are implicitly joined with an AND operator ('&' in domain syntax). To add an OR operation a pipe ('|') is used in place of a tuple, and it will affect the next two conditions. We will go into more details about domains in `Chapter 6, Views - Designing the User Interface`.  

过滤器的域

The domain used here  lters all done tasks (`'is_done', '=', True`) that either have the current user as responsible (`'user_id', '=', self.env.uid`) or don't have a current user set (`'user_id', '=', False`).  

What we just did was to completely overwrite the parent method, replacing it with a new implementation.  

But this is not what we usually want to do. Instead we should extend the existing logic to add some additional operations to it. Otherwise we could break already existing features. Existing logic is inserted in an overriding method using Python's super() command, to call the parent's version of the method.  

Let's see an example of this: we could write a better version of do_toggle_done() that only performs its action on the Tasks assigned to our user:  

然我们来看一看这种例子：我们可以

```python
       @api.one
       def do_toggle_done(self):
           if self.user_id != self.env.user:
               raise Exception('Only the responsible can do this!')
           else:
               return super(TodoTask, self).do_toggle_done()
```

These are the basic techniques for overriding and extending business logic de ned in model classes. Next we will see how to extend the user interface views.  

## Extending views 扩展视图
Forms, lists, and search views are de ned using the arch XML structures. To extend views we need a way to modify this XML. This means locating XML elements and then introducing modi cations on those points.  

Inherited views allow just that. An inherited view looks like this:  

```xml
   <record id="view_form_todo_task_inherited" model="ir.ui.view">
     <field name="name">Todo Task form – User extension</field>
     <field name="model">todo.task</field>
     <field name="inherit_id" ref="todo_app.view_form_todo_task"/>
     <field name="arch" type="xml">
         <!-- ...match and extend elements here! ... -->
     </field
   </record>
```

The `inherit_id` field identifies the view to be extended, by referring to its external identi er using the special ref attribute. External identi ers will be discussed in more detail in `Chapter 4, Data Serialization and Module Data`.  
The natural way to locate elements in XML is to use XPath expressions. For example, taking the form view defined in the previous chapter, the XPath expression to
locate the `<field name="is_done">` element is: `//field[@name]='is_done'`. This expression finds a `field` element with a name attribute equal to `is_done`. You can find more information on XPath at: `https://docs.python.org/2/library/xml. etree.elementtree.html#xpath-support`.  

定位在XML中元素的原生方法是使用XPath表示。例如，拿前面一章中定义的表单视图来说，其用来定位`<field name="is_done">`元素的XPath表达式为 `//field[@name]='is_done'`。 该表达式查找一个拥有name属性等于`is_done`的`field`元素。你可以在这里找到更多关于XPath的信息：`https://docs.python.org/2/library/xml. etree.elementtree.html#xpath-support`.  

Having name attributes on elements is important because it makes it a lot easier to select them for extension points. Once the extension point is located, it can be modified or have XML elements added near it.  

元素拥有name属性非常重要，因为这可以让扩展点在选择这些元素时更容易操作。只要扩展点被定位，元素就可以被修改，或者是在元素周围添加XML元素。  

As a practical example, to add the date_deadline field before the `is_done` field, we would write in the `arch`:  

例如，在`is_done`字段之前添加date_deadline字段，我们在`arch`中写入内容：  

```xml
<xpath expr="//field[@name]='is_done'" position="before">
     <field name="date_deadline" />
</xpath>
```

Fortunately Odoo provides shortcut notation for this, so most of the time we can avoid the XPath syntax entirely. Instead of the `xpath` element above we can use the element type we want to locate and its distinctive attributes. The above could also be written as:  

幸运地是Odoo对此提供了快捷标记，所以很多时候我们能够避免编写完整的XPath语法。与在上面使用的`xpath`元素相反，我们使用希望被定位的元素类型，以及该元素的不同属性。

```xml
<field name="is_done" position="before">
     <field name="date_deadline" />
</field>
```

Adding new fields next to existing fields is done often, so the `<field>` tag is frequently used as the locator. But any other tag can be used: `<sheet>`, `<group>`, `<div>`, and so on. The name attribute is usually the best choice for matching elements, but sometimes, we may need to use `string` (the displayed label text) or the CSS `class` element.  

在现存字段旁边添加新字段经常操作，所以`<field>`标签常常被用做定位符。但是其它标签也可以拿来用：`<sheet>`, `<group>`, `<div>`,等等。name属性通常是用来匹配元素的最佳选择，但是有时候，我们也需要使用`string`（显示在页面的标签文本）或者CSS`class`元素。  

The `position` attribute used with the locator element is optional, and can have the following values:  

`position`元素和定位符的联合使用是可选的，

- after: This is added to the parent element, after the matched node.
- before: This is added to the parent element, before the matched node.
- inside (the default value): This is appended to the content of the matched node.
- replace: This replaces the matched node. If used with empty content, it deletes an element.
- attributes: This modifies the XML attributes of the matched element (there are more details described following this list).

- after: 添加到匹配节点之后到父元素。
- before: 添加到匹配节点之前到父元素。
- inside（该定位符为默认值）：被追加到匹配节点的内容。
- replace: 提花匹配的节点。如果使用了空白内容，它会将元素删除。
- attributes: 修改匹配元素的XML属性（更多详情在下面的列表有描述）

The `attribute` position allows us to modify the matched element's attributes. This is done using `<attribute name="attr-name">` elements with the new attribute values.  

`attribute` 位置允许我们修改匹配元素的属性。使用拥有新属性值的`<attribute name="attr-name">`元素可以实现这种操作。

In the Task form, we have the **Active** field, but having it visible is not that useful. Maybe, we can hide it from the user. This can be done setting its `invisible` attribute:  

在Task表单中，我们设置了“Active”字段之外，

```xml
   <field name="active" position="attributes">
     <attribute name="invisible">1<attribute/>
</field>
```

Setting the invisible attribute to hide an element is a good alternative to using the replace locator to remove nodes. Removing should be avoided, since it can break extension models that may depend on the deleted node.  

设置不可见属性来隐藏一个元素

Finally, we can put all of this together, add the new fields, and get the following complete inheritance view to extend the to-do tasks form:  

最后，我们可以将这些内容放到一起，添加新字段，然后以下面完整的继承视图来扩展to-do tasks表单：  

```xml
   <record id="view_form_todo_task_inherited" model="ir.ui.view">
     <field name="name">Todo Task form – User extension</field>
     <field name="model">todo.task</field>
     <field name="inherit_id" ref="todo_app.view_form_todo_task"/>
     <field name="arch" type="xml">
       <field name="name" position="after">
         <field name="user_id" />
       </field>
       <field name="is_done" position="before">
         <field name="date_deadline" />
       </field>
       <field name="name" position="attributes">
         <attribute name="string">I have to...<attribute/>
       </field>
     </field
</record>
```

This should be added to a `todo_view.xml` file in our module, inside the `<openerp>` and `<data>` tags, as shown in the previous chapter.  

这些内容应该被添加到模块中的`todo_view.xml`文件，具体是在前一章中出现的`<openerp>`和`<data>`标签内部。  

>### Note
>Inherited views can also be inherited, but since this creates more intricate dependencies, it should be avoided.  

>### 注释
>继承到视图还可以被继承，但是这样做会产生更加错综复杂的依赖关系，所以你应该避免这样做。  

Also, we should not forget to add the data attribute to the `__openerp__.py` descriptor file:  

而且，我们不应该忘记将数据属性添加到描述符文件`__openerp__.py`：  

```json
'data': ['todo_view.xml'],
```

### Extending tree and search views 扩展树形视图和搜索视图
Tree and search view extensions are also defined using the arch XML structure, and they can be extended in the same way as form views. We will follow example of a extending the list and search views.  

树形视图和搜索视图扩展也可以使用arch XML结构来定义，

For the list view, we want to add the user field to it:  

对于列表视图，我们希望对它添加user字段：  

```xml
   <record id="view_tree_todo_task_inherited" model="ir.ui.view">
     <field name="name">Todo Task tree – User extension</field>
     <field name="model">todo.task</field>
     <field name="inherit_id" ref="todo_app.view_tree_todo_task"/>
     <field name="arch" type="xml">
       <field name="name" position="after">
         <field name="user_id" />
       </field>
     </field
</record>
```

For the search view, we will add search by user, and predefined filters for the user's own tasks and tasks not assigned to anyone:  

对于搜索视图，我们让用户来添加搜索，并给用户的所拥有的任务以及还没有分配给其它用户的用户预定义过滤器：  

```xml
   <record id="view_filter_todo_task_inherited" model="ir.ui.view">
     <field name="name">Todo Task tree – User extension</field>
     <field name="model">todo.task</field>
     <field name="inherit_id" ref="todo_app.view_filter_todo_task"/>
     <field name="arch" type="xml">
       <field name="name" position="after">
         <field name="user_id" />
         <filter name="filter_my_tasks" string="My Tasks"
                 domain="[('user_id','in',[uid,False])]" />
         <filter name="filter_not_assigned" string="Not Assigned"
                domain="[('user_id','=',False)]" />
    </field>
  </field
</record>
```

Don't worry too much about the views-specific syntax. We'll cover that in more detail in `Chapter 6, Views - Designing the User Interface`.  

## More on using inheritance to extend models
We have seen the basic in place extension of models, which is also the most frequent use of inheritance. But inheritance using the `_inherit` attribute has more powerful capabilities, such as **mixin** classes.  

We also have available the delegation inheritance method, using the `_inherits` attribute. It allows for a model to contain other models in a transparent way for the observer, while behind the scenes each model is handling its own data.  

Let's explore these possibilities in more detail.  

### Copying features using prototype inheritance
The method we used before to extend a model used just the `_inherit` attribute. We de ned a class inheriting the `todo.task` model, and added some features to it. The class _name was not explicitly set; implicitly it was `todo.task` also.  

But using the `_name` attribute allows us to create mixin classes, by setting it to the model we want to extend. Here is an example:  

```python
   from openerp import models


   class TodoTask(models.Model):
     _name = 'todo.task'
     _inherit = 'mail.thread'
```

This extends the `todo.task` model by copying to it the features of the `mail.thread` model. The `mail.thread` model implements the Odoo messages and followers features, and is reusable, so that it's easy to add those features to any model.  

Copying means that the inherited methods and  elds will also be available in the inheriting model. For fields this means that they will be also created and stored in the target model's database tables. The data records of the original (inherited) and the new (inheriting) models are kept unrelated. Only the de nitions are shared.  

These mixins are mostly used with abstract models, such as the `mail.thread` used
in the example. Abstract models are just like regular models except that no database representation is created for them. They act like templates, describing fields and logic to be reused in regular models. The  elds they de ne will only be created on those regular models inheriting from them. In a moment we will discuss in detail how
to use this to add `mail.thread` and its social networking features to our module. 
In practice when using mixins we rarely inherit from regular models, because this causes duplication of the same data structures.  

Odoo provides the delegation inheritance mechanism, which avoids data structure duplication, so it is usually preferred when inheriting from regular models. Let's look at it in more detail.  

### Embedding models using delegation inheritance
Delegation inheritance is the less frequently used model extension method, but it can provide very convenient solutions. It is used through the `_inherits` attribute (note the additional -s) with a dictionary mapping inherited models with  elds linking to them.  

委托继承很少使用的模型扩展方式，但是它可以提供非常便捷的解决办法。

A good example of this is the standard Users model, res.users, that has a Partner model embedded in it:  

这种情况的一个优选例子就是标准的拥有内嵌Partner模型的User模型res.users：  

```python
   from openerp import models, fields


   class User(models.Model):
     _name = 'res.users'
     _inherits = {'res.partner': 'partner_id'}
     partner_id = fields.Many2one('res.partner')
```

With delegation inheritance the model `res.users` embeds the inherited model `res.partner`, so that when a new `User` is created, a partner is also created and a reference to it is kept in the `partner_id` field of the `User`. It is similar to the polymorphism concept in object oriented programming.  

All fields of the inherited model, Partner, are available as if they were User  elds, through the delegation mechanism. For example, the partner name and address  elds are exposed as User  elds, but in fact they are being stored in the linked Partner model, and no data structure duplication occurs.  

The advantage of this, compared to prototype inheritance, is that there is no need
to repeat data structures in many tables, such as addresses. Any new model that needs to include an address can delegate that to an embedded Partner model. And if modi cations are introduced in the partner address  elds or validations, these are immediately available to all the models embedding it!  

>### Note
>Note that with delegation inheritance,  elds are inherited, but methods are not.  

### Using inheritance to add social network features
The social network module (technical name mail) provides the message board found at the bottom of many forms, also called Open Chatter, the followers are featured along with the logic regarding messages and noti cations. This is something we will often want to add to our models, so let's learn how to do it.  

The social network messaging features are provided by the mail.thread model of the mail module. To add it to a custom model we need to:  

- Have the module depend on mail.
- Have the class inherit from mail.thread.
- Have the Followers and Thread widgets added to the form view.
- Optionally, set up record rules for followers.

Let's follow this checklist:  

Regarding `#1`, since our extension module depends on todo_app, which in turn
depends on mail, the dependency on mail is already implicit, so no action is needed.  

Regarding `#2`, the inheritance on mail.thread is done using the `_inherit` attribute we used before. But our to-do task extension class is already using the _inherit attribute. Fortunately it can also accept a list of models to inherit from, so we can use that to make it also include the inheritance on mail.thread:  

```python
       _name = 'todo.task'
       _inherit = ['todo.task', 'mail.thread']
```

The `mail.thread` model is an abstract model. Abstract models are just like regular models except that they don't have a database representation; no actual tables are created for them. Abstract models are not meant to be used directly. Instead they
are expected to be used in mixin classes, as we just did. We can think of them as templates with ready-to-use features. To create an abstract class we just need it to use models.AbstractModel instead of `models.Model`.  

For `#3`, we want to add the social network widgets at the bottom of the form. We can reuse the inherited view we already created, `view_form_todo_task_inherited`, and add this into its arch data:  

```xml
<sheet position="after">
     <div class="oe_chatter">
       <field name="message_follower_ids" widget="mail_followers" />
       <field name="message_ids" widget="mail_thread" />
     </div>
 </sheet>
```

The two fields we add here haven't been explicitly declared by us, but they are provided by the `mail.thread` model.  

The  nal step is to set up record rules for followers. This is only needed if our model has record rules implemented that limit other users' access to its records. In this case, we need to make sure that the followers for each record have at least read access to it.  

We do have record rules on the to-do task model so we need to address this, and that's what we will do in the next section.  

## Modifying data
Unlike views, regular data records don't have an XML arch structure and can't be extended using XPath expressions. But they can still be modi ed to replace values in their fields.  

The `<record id="x" model="y">` element is actually performing an insert or update operation on the model: if x does not exist, it is created; otherwise, it is updated/written over.  

Since records in other modules can be accessed using a `<model>.<identifier>` identi er, it's perfectly legal for our module to overwrite something that was written before by another module.  

>### Note
>Note that the dot is reserved to separate the module name from the object identi er, so they shouldn't be used in identi ers. Instead use the underscore.  

As an example, let's change the menu option created by the todo_app module to into **My To Do**. For that we could add the following to the todo_user/todo_view. xml file:  

```xml
<!-- Modify menu item -->
       <record id="todo_app.menu_todo_task" model="ir.ui.menu">
           <field name="name">My To-Do</field>
       </record>
       <!-- Action to open To-Do Task list -->
       <record model="ir.actions.act_window"
           id="todo_app.action_todo_task">
           <field name="context">
               {'search_default_filter_my_tasks': True}
           </field>
     </record>
```

### Extending the record rules 扩展记录规则
The To-Do application included a record rule to ensure that each task would only be visible to the user that created it. But now, with the addition of the social features, we need the task followers to also have access to them. The social network module does not handle this by itself.  

Also, now tasks can have users assigned to them, so it makes more sense to have the access rules to work on the responsible user instead of the user who created the task.  

The plan would be the same as we did for the menu item: overwrite the `todo_app.todo_task_user_rule` to modify the domain_force  eld to a new value.  

Unfortunately this won't work this time. Remember the `<data no_update="1">` we used in the security rules XML  le: it prevents later write operations on it.  

Since updates on that record are being prevented, we need a workaround. That will be to delete that record and add a replacement for it in our module.  

To keep things organized, we will create a security/todo_access_rules.xml file and add the following content to it:  

```xml
   <?xml version="1.0" encoding="utf-8"?>
   <openerp>
     <data noupdate="1">
       <delete model="ir.rule" search="[('id', '=',
        ref('todo_app.todo_task_user_rule'))]" />
       <record id="todo_task_per_user_rule" model="ir.rule">
           <field name="name">ToDo Tasks only for owner</field>
           <field name="model_id" ref="model_todo_task"/>
           <field name="groups"
             eval="[(4, ref('base.group_user'))]"/>
           <field name="domain_force">
             ['|',('user_id','in', [user.id,False]),
               ('message_follower_ids','in',[user.partner_id.id])]
         </field>
    </record>
  </data>
</openerp>
```

This finds and deletes the `todo_task_user_rule` record rule from the todo_app module, and then creates a new `todo_task_per_user_rule` record rule. The domain filter we will now use makes a task visible to the responsible user user_id, to everyone if the responsible user is not set (equals False), and to all followers. 
The rule will run in a context where user is available and represents the current session user. The followers are partners, not User objects, so instead of `user.id`,
we need to use `user.partner_id.id`.  



>### Tips
>Working on data  les with `<data noupdate="1">` is tricky because any later edit won't be updated on Odoo. To avoid that, temporarily use `<data noupdate="0">` during development, and change it back only when you're done with the module.  

As usual, we must not forget to add the new  le to the `__openerp__.py` descriptor  le in the data attribute:  

```python
'data': ['todo_view.xml', 'security/todo_access_rules.xml'],
```

Notice that on module upgrade, the `<delete>` element will produce an ugly warning message, because the record to delete does not exist anymore. It is not an error and the upgrade will be successful, so we don't need to worry about it.  

## Summary
You should now be able to create new modules to extend existing modules. We saw how to extend the To-Do module created in the previous chapter.  

现在，你应该能够创建新模块来括扩展现存的模块。我们在前一章也学习了对需要扩展的To－Do模块的创建。  

New features were added onto the several layers that make up an application.
We extended the Odoo model to add new fields, and extended the methods with its business logic. Next, we modi ed the views to make the new  elds available on them. Finally, you learned how to extend a model by inheriting from other models, and we used that to add the social network features to our To-Do app.  

新特性被添加到了装饰器一个应用的多个层面。我们扩展Odoo模块以添加新字段，并使用它的业务逻辑来扩展方法。接下来，我们修改视图，以便可以在视图上使用新的字段。最后，你学会如何通过继承其它模型来扩展一个模型，同时我们使用这个方法对To-Do应用添加社交网络功能。  

With these three chapters, we had an overview of the common activities involved in Odoo development, from Odoo installation and setup to module creation and extension. The next chapters will focus on specific areas, most of which we visited briefly in these overviews. In the following chapter, we will address data serialization and the usage of XML and CSV  les in more detail.  

通过这三章，从Odoo的安装和设置，到模块创建和扩展，我们对常见的Odoo开发活动就有了一个大概了解。接下的章节我们关注于特殊的领域，
